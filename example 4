{
  "id": "nyaa-non-eng",
  "name": "Nyaa (Non-English)",
  "description": "Nyaa provider for non-english torrents",
  "manifestURI": "https://island.clap.ing/api/extensions/anime-torrent-providers/nyaa/nyaa-non-eng.json",
  "version": "1.0.0",
  "author": "Island",
  "type": "anime-torrent-provider",
  "icon": "https://island.clap.ing/api/extensions/icons/nyaa.png",
  "language": "typescript",
  "lang": "multi",
  "userConfig": {
    "requiresConfig": false,
    "version": 1,
    "fields": [
      {
        "name": "apiUrl",
        "label": "API URL",
        "type": "text",
        "default": "https://nyaa.si"
      },
      {
        "name": "category",
        "label": "Category",
        "type": "text",
        "default": "1_3"
      }
    ]
  },
  "payload": "/// <reference path=\"../anime-torrent-provider.d.ts\" />\n/// <reference path=\"../../core.d.ts\" />\n\ninterface ProviderConfig {\n    baseUrl: string;\n    category: string;\n}\n\ninterface RawTorrent {\n    name: string;\n    link: string; // GUID/Page URL\n    downloadUrl: string; // .torrent file URL\n    date: string; // raw date string\n    seeders: string;\n    leechers: string;\n    downloads: string;\n    infoHash: string;\n    size: string; // formatted size string\n}\n\nclass Provider {\n    canSmartSearch = true\n    supportsAdult = false\n\n    async getLatest(): Promise<AnimeTorrent[]> {\n        try {\n            const url = this.buildURL(\"\")\n            console.log(\"Nyaa: Fetching latest from \" + url)\n\n            const res = await fetch(url)\n            const rssText = await res.text()\n\n            const rawTorrents = this.parseRSSFeed(rssText)\n\n            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t, \"nyaa\"))\n\n            console.log(`Nyaa: Found ${torrents.length} latest torrents`)\n            return torrents\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error fetching latest: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async search(options: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            const url = this.buildURL(options.query)\n            console.log(\"Nyaa: Searching for \" + options.query)\n\n            const res = await fetch(url)\n            const rssText = await res.text()\n\n            const rawTorrents = this.parseRSSFeed(rssText)\n            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t, \"nyaa\"))\n\n            console.log(`Nyaa: Found ${torrents.length} torrents for query`)\n            return torrents\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error searching: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async smartSearch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        try {\n            const queries = this.buildSmartSearchQueries(options)\n            if (!queries || queries.length === 0) {\n                console.warn(\"Nyaa: Smart search could not build queries\")\n                return []\n            }\n\n            console.log(\"Nyaa: Smart searching with queries: \" + JSON.stringify(queries))\n\n            const searchPromises = queries.map(async (query) => {\n                try {\n                    const url = this.buildURL(query)\n                    console.log(\"Nyaa: Smart search URL: \" + url)\n                    const res = await fetch(url)\n                    const rssText = await res.text()\n                    return this.parseRSSFeed(rssText)\n                }\n                catch (e) {\n                    console.error(\"Nyaa: Smart search sub-query failed: \" + (e as Error).message)\n                    return []\n                }\n            })\n\n            const results = await Promise.all(searchPromises)\n            const allRawTorrents = results.flat()\n\n            // Remove duplicates\n            const uniqueTorrentsMap = new Map<string, any>()\n            allRawTorrents.forEach(t => {\n                // Use downloadUrl (.torrent link) as unique key\n                if (t.downloadUrl && !uniqueTorrentsMap.has(t.downloadUrl)) {\n                    uniqueTorrentsMap.set(t.downloadUrl, t)\n                }\n            })\n\n            let torrents = [...uniqueTorrentsMap.values()].map(t => this.toAnimeTorrent(t, \"nyaa\"))\n            uniqueTorrentsMap.clear()\n\n            // Filter by episode number if not batch\n            if (!options.batch) {\n                torrents = torrents.filter(t => {\n                    const relEp = t.episodeNumber\n                    if (relEp === -1) return false\n\n                    const absEp = (options.media.absoluteSeasonOffset || 0) + options.episodeNumber\n\n                    return options.episodeNumber === relEp || absEp === relEp\n                })\n                console.log(`Nyaa: Filtered to ${torrents.length} torrents for episode ${options.episodeNumber}`)\n            }\n\n            return torrents\n\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error in smart search: \" + (error as Error).message)\n            return []\n        }\n    }\n\n    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        return torrent.infoHash || \"\"\n    }\n\n    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        try {\n            const res = await fetch(torrent.link)\n            const html = await res.text()\n            const $ = LoadDoc(html)\n\n            let magnetLink = \"\"\n\n            // Search for the magnet link\n            $(\"a.card-footer-item, a[href^=\\\"magnet:\\\"]\").each((i: number, el) => {\n                const href = el.attr(\"href\")\n                if (href && href.startsWith(\"magnet:\")) {\n                    magnetLink = href\n                    return false // Break the loop\n                }\n            })\n\n            if (!magnetLink) {\n                throw new Error(\"Magnet link not found on page\")\n            }\n\n            return magnetLink\n        }\n        catch (error) {\n            console.error(\"Nyaa: Error fetching magnet link: \" + (error as Error).message)\n            throw new Error(\"Could not fetch magnet link for: \" + torrent.name)\n        }\n    }\n\n    getSettings(): AnimeProviderSettings {\n        return {\n            canSmartSearch: this.canSmartSearch,\n            smartSearchFilters: [\"batch\", \"episodeNumber\", \"resolution\", \"query\"],\n            supportsAdult: false,\n            type: \"main\",\n        }\n    }\n\n    private getProviderSettings(): ProviderConfig {\n        let url: string = $getUserPreference(\"apiUrl\") || \"nyaa.si\"\n        if (!url.startsWith(\"http\")) {\n            url = \"https://\" + url\n        }\n        return {\n            baseUrl: url.replace(/\\/$/, \"\"), // Remove trailing slash\n            category: $getUserPreference(\"category\") || \"1_2\",\n        }\n    }\n\n    private buildURL(query: string, sortBy: string = \"seeders\"): string {\n        const { baseUrl, category } = this.getProviderSettings()\n\n        const queryString = `page=rss&q=${encodeURIComponent(query)}&c=${category}&f=0&s=${sortBy}&o=desc`\n        return `${baseUrl}/?${queryString}`\n    }\n\n    private parseRSSFeed(rssText: string): RawTorrent[] {\n        const torrents: RawTorrent[] = []\n\n        // Helper to extract content between XML tags\n        const getTagContent = (xml: string, tag: string): string => {\n            const regex = new RegExp(`<${tag}[^>]*>([^<]*)</${tag}>`)\n            const match = xml.match(regex)\n            return match ? match[1].trim() : \"\"\n        }\n\n        // Helper to extract content from nyaa namespace tags\n        const getNyaaTagContent = (xml: string, tag: string): string => {\n            const regex = new RegExp(`<nyaa:${tag}[^>]*>([^<]*)</nyaa:${tag}>`)\n            const match = xml.match(regex)\n            return match ? match[1].trim() : \"\"\n        }\n\n        // Split XML into items\n        const itemRegex = /<item>([\\s\\S]*?)<\\/item>/g\n        let match\n\n        while ((match = itemRegex.exec(rssText)) !== null) {\n            const itemXml = match[1]\n\n            const title = getTagContent(itemXml, \"title\")\n            const downloadUrl = getTagContent(itemXml, \"link\") // .torrent file URL\n            const link = getTagContent(itemXml, \"guid\")      // Page URL\n            const pubDate = getTagContent(itemXml, \"pubDate\")\n            const seeders = getNyaaTagContent(itemXml, \"seeders\")\n            const leechers = getNyaaTagContent(itemXml, \"leechers\")\n            const downloads = getNyaaTagContent(itemXml, \"downloads\")\n            const infoHash = getNyaaTagContent(itemXml, \"infoHash\")\n            const size = getNyaaTagContent(itemXml, \"size\")\n\n            const torrent: RawTorrent = {\n                name: title,\n                link: link,\n                downloadUrl: downloadUrl,\n                date: pubDate,\n                seeders: seeders,\n                leechers: leechers,\n                downloads: downloads,\n                infoHash: infoHash,\n                size: size,\n            }\n\n            torrents.push(torrent)\n        }\n\n        return torrents\n    }\n\n    private toAnimeTorrent(t: RawTorrent, providerName: string): AnimeTorrent {\n        const metadata = $habari.parse(t.name)\n\n        const seeders = parseInt(t.seeders) || 0\n        const leechers = parseInt(t.leechers) || 0\n        const downloads = parseInt(t.downloads) || 0\n\n        let formattedDate = \"\"\n        try {\n            const parsedDate = new Date(t.date)\n            if (!isNaN(parsedDate.getTime())) {\n                formattedDate = parsedDate.toISOString()\n            }\n        }\n        catch (e) {\n            console.warn(\"Nyaa: Failed to parse date: \" + t.date)\n        }\n\n        let sizeInBytes = 0\n        const sizeMatch = t.size.match(/([\\d.]+)\\s*([KMGT]?i?B)/i)\n        if (sizeMatch) {\n            const size = parseFloat(sizeMatch[1])\n            const unit = sizeMatch[2].toUpperCase()\n            if (unit.endsWith(\"IB\")) {\n                if (unit.startsWith(\"M\")) sizeInBytes = size * Math.pow(1024, 2)\n                else if (unit.startsWith(\"G\")) sizeInBytes = size * Math.pow(1024, 3)\n                else if (unit.startsWith(\"T\")) sizeInBytes = size * Math.pow(1024, 4)\n                else sizeInBytes = size * 1024\n            } else {\n                if (unit.startsWith(\"M\")) sizeInBytes = size * Math.pow(1000, 2)\n                else if (unit.startsWith(\"G\")) sizeInBytes = size * Math.pow(1000, 3)\n                else if (unit.startsWith(\"T\")) sizeInBytes = size * Math.pow(1000, 4)\n                else sizeInBytes = size * 1000\n            }\n        }\n\n        let episode = -1\n        if (metadata.episode_number && metadata.episode_number.length >= 1) {\n            episode = parseInt(metadata.episode_number[0]) || -1\n        }\n\n        let isBatchByGuess = false\n        if (metadata.episode_number && metadata.episode_number.length > 1) {\n            isBatchByGuess = true\n        }\n        if (/\\b(batch|complete|collection|seasons?|parts?)\\b/i.test(t.name)) {\n            isBatchByGuess = true\n        }\n\n        if (isBatchByGuess) {\n            episode = -1\n        }\n\n        return {\n            name: t.name,\n            date: formattedDate,\n            size: Math.round(sizeInBytes),\n            formattedSize: t.size,\n            seeders: seeders,\n            leechers: leechers,\n            downloadCount: downloads,\n            link: t.link,\n            downloadUrl: t.downloadUrl,\n            infoHash: t.infoHash,\n            magnetLink: \"\",\n            resolution: metadata.video_resolution || \"\",\n            isBatch: isBatchByGuess,\n            episodeNumber: episode,\n            releaseGroup: metadata.release_group || \"\",\n            isBestRelease: false,\n            confirmed: false,\n        }\n    }\n\n    private buildSmartSearchQueries(opts: AnimeSmartSearchOptions): string[] {\n        const { media, query: userQuery, batch, episodeNumber, resolution } = opts\n\n        let romTitle = media.romajiTitle || \"\"\n        let engTitle = media.englishTitle || \"\"\n        let allTitles = [romTitle, engTitle, ...(media.synonyms || [])].filter(Boolean)\n\n        let season = 0\n        let part = 0\n        let titles: string[] = []\n\n        if (!userQuery) {\n            allTitles.forEach(title => {\n                let s: number, p: number, cTitle: string;\n                [s, cTitle] = this.extractSeasonNumber(title);\n                [p, cTitle] = this.extractPartNumber(cTitle)\n                if (s !== 0) season = s\n                if (p !== 0) part = p\n                if (cTitle) titles.push(cTitle)\n            })\n\n            if (season === 0) {\n                (media.synonyms || []).forEach(synonym => {\n                    const [s, _] = this.extractSeasonNumber(synonym)\n                    if (s !== 0) season = s\n                })\n            }\n\n            if (season === 0 && part === 0 && titles.length === 0) {\n                if (romTitle) titles.push(romTitle)\n                if (engTitle) titles.push(engTitle)\n            }\n\n            [romTitle, engTitle].filter(Boolean).forEach(title => {\n                const split = title.split(\":\")\n                if (split.length > 1 && split[0].length > 8) {\n                    titles.push(split[0])\n                }\n            })\n\n            if (season === 0) {\n                if (/\\biii\\b/i.test(romTitle) || (engTitle && /\\biii\\b/i.test(engTitle))) season = 3\n                else if (/\\bii\\b/i.test(romTitle) || (engTitle && /\\bii\\b/i.test(engTitle))) season = 2\n            }\n\n            titles = titles.map(t => {\n                let clean = t.replace(/:/g, \" \").replace(/-/g, \" \").trim()\n                clean = clean.replace(/\\s+/g, \" \")\n                clean = clean.toLowerCase()\n                if (season !== 0) {\n                    clean = clean.replace(/\\biii\\b/gi, \"\").replace(/\\bii\\b/gi, \"\")\n                }\n                return clean.trim()\n            })\n\n            titles = [...new Set(titles.filter(Boolean))]\n\n        } else {\n            titles = [userQuery.toLowerCase()]\n        }\n\n        if (titles.length === 0) {\n            return []\n        }\n\n        const canBatch = media.status === \"FINISHED\" && (media.episodeCount || 0) > 0\n        let normalBuff = \"\"\n        let batchBuff = \"\"\n\n        // Parameters\n        if (batch && canBatch && !(media.format === \"MOVIE\" && (media.episodeCount || 0) === 1)) {\n            if (season !== 0) batchBuff += this.buildSeasonString(season)\n            if (part !== 0) batchBuff += this.buildPartString(part)\n            batchBuff += this.buildBatchString(media)\n        } else {\n            normalBuff += this.buildSeasonString(season)\n            if (part !== 0) normalBuff += this.buildPartString(part)\n            if (!(media.format === \"MOVIE\" && (media.episodeCount || 0) === 1)) {\n                normalBuff += this.buildEpisodeString(episodeNumber)\n            }\n        }\n\n        let titleStr = this.buildTitleString(titles)\n        if (userQuery) {\n            titleStr = `(${userQuery})`\n        }\n\n        const batchStr = batchBuff\n        const normalStr = normalBuff\n\n        let query = `${titleStr}${batchStr}${normalStr}`\n\n        // Resolution part\n        const resStr = resolution ? `(${resolution})` : \"(360|480|720|1080)\"\n        query += resStr\n\n        const queries = [query]\n\n        // Absolute episode addition\n        if (!batch && (media.absoluteSeasonOffset || 0) > 0 && !(media.format === \"MOVIE\" && (media.episodeCount || 0) === 1)) {\n            const absEp = episodeNumber + (media.absoluteSeasonOffset || 0)\n            const query2 = `${titleStr}(${absEp})${resStr}`\n            queries.push(query2)\n        }\n\n        return queries\n    }\n\n    private zeropad(v: number): string {\n        const s = String(v)\n        return s.length < 2 ? \"0\" + s : s\n    }\n\n    private buildTitleString(titles: string[]): string {\n        if (titles.length === 1) {\n            return `(${titles[0]})`\n        }\n        const quotedTitles = titles.map(t => `\"${t}\"`)\n        return `(${quotedTitles.join(\"|\")})`\n    }\n\n    private buildEpisodeString(ep: number): string {\n        const pEp = this.zeropad(ep)\n        return `(${pEp}|e${pEp}|e${pEp}v|${pEp}v|ep${pEp}|ep${ep})`\n    }\n\n    private buildSeasonString(season: number): string {\n        if (season === 0) return \"\"\n        const pS = this.zeropad(season)\n        return `(\"season ${season}\"|\"season ${pS}\"|\"s${season}\"|\"s${pS}\")`\n    }\n\n    private buildPartString(part: number): string {\n        if (part === 0) return \"\"\n        return `(\"part ${part}\")`\n    }\n\n    private buildBatchString(media: AnimeSmartSearchOptions[\"media\"]): string {\n        const epCount = this.zeropad(media.episodeCount || 0)\n        const parts = [\n            `\"01 - ${epCount}\"`,\n            `\"01 ~ ${epCount}\"`,\n            `\"Batch\"`,\n            `\"Complete\"`,\n            `\"+ OVA\"`,\n            `\"+ Specials\"`,\n            `\"+ Special\"`,\n            `\"Seasons\"`,\n            `\"Parts\"`,\n        ]\n        return `(${parts.join(\"|\")})`\n    }\n\n    private extractSeasonNumber(title: string): [number, string] {\n        const match = title.match(/\\b(season|s)\\s*(\\d{1,2})\\b/i)\n        if (match && match[2]) {\n            const cleanTitle = title.replace(match[0], \"\").trim()\n            return [parseInt(match[2]), cleanTitle]\n        }\n        return [0, title]\n    }\n\n    private extractPartNumber(title: string): [number, string] {\n        const match = title.match(/\\b(part|p)\\s*(\\d{1.2})\\b/i)\n        if (match && match[2]) {\n            const cleanTitle = title.replace(match[0], \"\").trim()\n            return [parseInt(match[2]), cleanTitle]\n        }\n        return [0, title]\n    }\n\n}\n"
}

/// <reference path="../anime-torrent-provider.d.ts" />
/// <reference path="../../core.d.ts" />

interface ProviderConfig {
    baseUrl: string;
    category: string;
}

interface RawTorrent {
    name: string;
    link: string; // GUID/Page URL
    downloadUrl: string; // .torrent file URL
    date: string; // raw date string
    seeders: string;
    leechers: string;
    downloads: string;
    infoHash: string;
    size: string; // formatted size string
}

class Provider {
    canSmartSearch = true
    supportsAdult = false

    async getLatest(): Promise<AnimeTorrent[]> {
        try {
            const url = this.buildURL("")
            console.log("Nyaa: Fetching latest from " + url)

            const res = await fetch(url)
            const rssText = await res.text()

            const rawTorrents = this.parseRSSFeed(rssText)

            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t, "nyaa"))

            console.log(`Nyaa: Found ${torrents.length} latest torrents`)
            return torrents
        }
        catch (error) {
            console.error("Nyaa: Error fetching latest: " + (error as Error).message)
            return []
        }
    }

    async search(options: AnimeSearchOptions): Promise<AnimeTorrent[]> {
        try {
            const url = this.buildURL(options.query)
            console.log("Nyaa: Searching for " + options.query)

            const res = await fetch(url)
            const rssText = await res.text()

            const rawTorrents = this.parseRSSFeed(rssText)
            const torrents = rawTorrents.map(t => this.toAnimeTorrent(t, "nyaa"))

            console.log(`Nyaa: Found ${torrents.length} torrents for query`)
            return torrents
        }
        catch (error) {
            console.error("Nyaa: Error searching: " + (error as Error).message)
            return []
        }
    }

    async smartSearch(options: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {
        try {
            const queries = this.buildSmartSearchQueries(options)
            if (!queries || queries.length === 0) {
                console.warn("Nyaa: Smart search could not build queries")
                return []
            }

            console.log("Nyaa: Smart searching with queries: " + JSON.stringify(queries))

            const searchPromises = queries.map(async (query) => {
                try {
                    const url = this.buildURL(query)
                    console.log("Nyaa: Smart search URL: " + url)
                    const res = await fetch(url)
                    const rssText = await res.text()
                    return this.parseRSSFeed(rssText)
                }
                catch (e) {
                    console.error("Nyaa: Smart search sub-query failed: " + (e as Error).message)
                    return []
                }
            })

            const results = await Promise.all(searchPromises)
            const allRawTorrents = results.flat()

            // Remove duplicates
            const uniqueTorrentsMap = new Map<string, any>()
            allRawTorrents.forEach(t => {
                // Use downloadUrl (.torrent link) as unique key
                if (t.downloadUrl && !uniqueTorrentsMap.has(t.downloadUrl)) {
                    uniqueTorrentsMap.set(t.downloadUrl, t)
                }
            })

            let torrents = [...uniqueTorrentsMap.values()].map(t => this.toAnimeTorrent(t, "nyaa"))
            uniqueTorrentsMap.clear()

            // Filter by episode number if not batch
            if (!options.batch) {
                torrents = torrents.filter(t => {
                    const relEp = t.episodeNumber
                    if (relEp === -1) return false

                    const absEp = (options.media.absoluteSeasonOffset || 0) + options.episodeNumber

                    return options.episodeNumber === relEp || absEp === relEp
                })
                console.log(`Nyaa: Filtered to ${torrents.length} torrents for episode ${options.episodeNumber}`)
            }

            return torrents

        }
        catch (error) {
            console.error("Nyaa: Error in smart search: " + (error as Error).message)
            return []
        }
    }

    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {
        return torrent.infoHash || ""
    }

    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {
        try {
            const res = await fetch(torrent.link)
            const html = await res.text()
            const $ = LoadDoc(html)

            let magnetLink = ""

            // Search for the magnet link
            $("a.card-footer-item, a[href^=\"magnet:\"]").each((i: number, el) => {
                const href = el.attr("href")
                if (href && href.startsWith("magnet:")) {
                    magnetLink = href
                    return false // Break the loop
                }
            })

            if (!magnetLink) {
                throw new Error("Magnet link not found on page")
            }

            return magnetLink
        }
        catch (error) {
            console.error("Nyaa: Error fetching magnet link: " + (error as Error).message)
            throw new Error("Could not fetch magnet link for: " + torrent.name)
        }
    }

    getSettings(): AnimeProviderSettings {
        return {
            canSmartSearch: this.canSmartSearch,
            smartSearchFilters: ["batch", "episodeNumber", "resolution", "query"],
            supportsAdult: false,
            type: "main",
        }
    }

    private getProviderSettings(): ProviderConfig {
        let url: string = $getUserPreference("apiUrl") || "nyaa.si"
        if (!url.startsWith("http")) {
            url = "https://" + url
        }
        return {
            baseUrl: url.replace(/\/$/, ""), // Remove trailing slash
            category: $getUserPreference("category") || "1_2",
        }
    }

    private buildURL(query: string, sortBy: string = "seeders"): string {
        const { baseUrl, category } = this.getProviderSettings()

        const queryString = `page=rss&q=${encodeURIComponent(query)}&c=${category}&f=0&s=${sortBy}&o=desc`
        return `${baseUrl}/?${queryString}`
    }

    private parseRSSFeed(rssText: string): RawTorrent[] {
        const torrents: RawTorrent[] = []

        // Helper to extract content between XML tags
        const getTagContent = (xml: string, tag: string): string => {
            const regex = new RegExp(`<${tag}[^>]*>([^<]*)</${tag}>`)
            const match = xml.match(regex)
            return match ? match[1].trim() : ""
        }

        // Helper to extract content from nyaa namespace tags
        const getNyaaTagContent = (xml: string, tag: string): string => {
            const regex = new RegExp(`<nyaa:${tag}[^>]*>([^<]*)</nyaa:${tag}>`)
            const match = xml.match(regex)
            return match ? match[1].trim() : ""
        }

        // Split XML into items
        const itemRegex = /<item>([\s\S]*?)<\/item>/g
        let match

        while ((match = itemRegex.exec(rssText)) !== null) {
            const itemXml = match[1]

            const title = getTagContent(itemXml, "title")
            const downloadUrl = getTagContent(itemXml, "link") // .torrent file URL
            const link = getTagContent(itemXml, "guid")      // Page URL
            const pubDate = getTagContent(itemXml, "pubDate")
            const seeders = getNyaaTagContent(itemXml, "seeders")
            const leechers = getNyaaTagContent(itemXml, "leechers")
            const downloads = getNyaaTagContent(itemXml, "downloads")
            const infoHash = getNyaaTagContent(itemXml, "infoHash")
            const size = getNyaaTagContent(itemXml, "size")

            const torrent: RawTorrent = {
                name: title,
                link: link,
                downloadUrl: downloadUrl,
                date: pubDate,
                seeders: seeders,
                leechers: leechers,
                downloads: downloads,
                infoHash: infoHash,
                size: size,
            }

            torrents.push(torrent)
        }

        return torrents
    }

    private toAnimeTorrent(t: RawTorrent, providerName: string): AnimeTorrent {
        const metadata = $habari.parse(t.name)

        const seeders = parseInt(t.seeders) || 0
        const leechers = parseInt(t.leechers) || 0
        const downloads = parseInt(t.downloads) || 0

        let formattedDate = ""
        try {
            const parsedDate = new Date(t.date)
            if (!isNaN(parsedDate.getTime())) {
                formattedDate = parsedDate.toISOString()
            }
        }
        catch (e) {
            console.warn("Nyaa: Failed to parse date: " + t.date)
        }

        let sizeInBytes = 0
        const sizeMatch = t.size.match(/([\d.]+)\s*([KMGT]?i?B)/i)
        if (sizeMatch) {
            const size = parseFloat(sizeMatch[1])
            const unit = sizeMatch[2].toUpperCase()
            if (unit.endsWith("IB")) {
                if (unit.startsWith("M")) sizeInBytes = size * Math.pow(1024, 2)
                else if (unit.startsWith("G")) sizeInBytes = size * Math.pow(1024, 3)
                else if (unit.startsWith("T")) sizeInBytes = size * Math.pow(1024, 4)
                else sizeInBytes = size * 1024
            } else {
                if (unit.startsWith("M")) sizeInBytes = size * Math.pow(1000, 2)
                else if (unit.startsWith("G")) sizeInBytes = size * Math.pow(1000, 3)
                else if (unit.startsWith("T")) sizeInBytes = size * Math.pow(1000, 4)
                else sizeInBytes = size * 1000
            }
        }

        let episode = -1
        if (metadata.episode_number && metadata.episode_number.length >= 1) {
            episode = parseInt(metadata.episode_number[0]) || -1
        }

        let isBatchByGuess = false
        if (metadata.episode_number && metadata.episode_number.length > 1) {
            isBatchByGuess = true
        }
        if (/\b(batch|complete|collection|seasons?|parts?)\b/i.test(t.name)) {
            isBatchByGuess = true
        }

        if (isBatchByGuess) {
            episode = -1
        }

        return {
            name: t.name,
            date: formattedDate,
            size: Math.round(sizeInBytes),
            formattedSize: t.size,
            seeders: seeders,
            leechers: leechers,
            downloadCount: downloads,
            link: t.link,
            downloadUrl: t.downloadUrl,
            infoHash: t.infoHash,
            magnetLink: "",
            resolution: metadata.video_resolution || "",
            isBatch: isBatchByGuess,
            episodeNumber: episode,
            releaseGroup: metadata.release_group || "",
            isBestRelease: false,
            confirmed: false,
        }
    }

    private buildSmartSearchQueries(opts: AnimeSmartSearchOptions): string[] {
        const { media, query: userQuery, batch, episodeNumber, resolution } = opts

        let romTitle = media.romajiTitle || ""
        let engTitle = media.englishTitle || ""
        let allTitles = [romTitle, engTitle, ...(media.synonyms || [])].filter(Boolean)

        let season = 0
        let part = 0
        let titles: string[] = []

        if (!userQuery) {
            allTitles.forEach(title => {
                let s: number, p: number, cTitle: string;
                [s, cTitle] = this.extractSeasonNumber(title);
                [p, cTitle] = this.extractPartNumber(cTitle)
                if (s !== 0) season = s
                if (p !== 0) part = p
                if (cTitle) titles.push(cTitle)
            })

            if (season === 0) {
                (media.synonyms || []).forEach(synonym => {
                    const [s, _] = this.extractSeasonNumber(synonym)
                    if (s !== 0) season = s
                })
            }

            if (season === 0 && part === 0 && titles.length === 0) {
                if (romTitle) titles.push(romTitle)
                if (engTitle) titles.push(engTitle)
            }

            [romTitle, engTitle].filter(Boolean).forEach(title => {
                const split = title.split(":")
                if (split.length > 1 && split[0].length > 8) {
                    titles.push(split[0])
                }
            })

            if (season === 0) {
                if (/\biii\b/i.test(romTitle) || (engTitle && /\biii\b/i.test(engTitle))) season = 3
                else if (/\bii\b/i.test(romTitle) || (engTitle && /\bii\b/i.test(engTitle))) season = 2
            }

            titles = titles.map(t => {
                let clean = t.replace(/:/g, " ").replace(/-/g, " ").trim()
                clean = clean.replace(/\s+/g, " ")
                clean = clean.toLowerCase()
                if (season !== 0) {
                    clean = clean.replace(/\biii\b/gi, "").replace(/\bii\b/gi, "")
                }
                return clean.trim()
            })

            titles = [...new Set(titles.filter(Boolean))]

        } else {
            titles = [userQuery.toLowerCase()]
        }

        if (titles.length === 0) {
            return []
        }

        const canBatch = media.status === "FINISHED" && (media.episodeCount || 0) > 0
        let normalBuff = ""
        let batchBuff = ""

        // Parameters
        if (batch && canBatch && !(media.format === "MOVIE" && (media.episodeCount || 0) === 1)) {
            if (season !== 0) batchBuff += this.buildSeasonString(season)
            if (part !== 0) batchBuff += this.buildPartString(part)
            batchBuff += this.buildBatchString(media)
        } else {
            normalBuff += this.buildSeasonString(season)
            if (part !== 0) normalBuff += this.buildPartString(part)
            if (!(media.format === "MOVIE" && (media.episodeCount || 0) === 1)) {
                normalBuff += this.buildEpisodeString(episodeNumber)
            }
        }

        let titleStr = this.buildTitleString(titles)
        if (userQuery) {
            titleStr = `(${userQuery})`
        }

        const batchStr = batchBuff
        const normalStr = normalBuff

        let query = `${titleStr}${batchStr}${normalStr}`

        // Resolution part
        const resStr = resolution ? `(${resolution})` : "(360|480|720|1080)"
        query += resStr

        const queries = [query]

        // Absolute episode addition
        if (!batch && (media.absoluteSeasonOffset || 0) > 0 && !(media.format === "MOVIE" && (media.episodeCount || 0) === 1)) {
            const absEp = episodeNumber + (media.absoluteSeasonOffset || 0)
            const query2 = `${titleStr}(${absEp})${resStr}`
            queries.push(query2)
        }

        return queries
    }

    private zeropad(v: number): string {
        const s = String(v)
        return s.length < 2 ? "0" + s : s
    }

    private buildTitleString(titles: string[]): string {
        if (titles.length === 1) {
            return `(${titles[0]})`
        }
        const quotedTitles = titles.map(t => `"${t}"`)
        return `(${quotedTitles.join("|")})`
    }

    private buildEpisodeString(ep: number): string {
        const pEp = this.zeropad(ep)
        return `(${pEp}|e${pEp}|e${pEp}v|${pEp}v|ep${pEp}|ep${ep})`
    }

    private buildSeasonString(season: number): string {
        if (season === 0) return ""
        const pS = this.zeropad(season)
        return `("season ${season}"|"season ${pS}"|"s${season}"|"s${pS}")`
    }

    private buildPartString(part: number): string {
        if (part === 0) return ""
        return `("part ${part}")`
    }

    private buildBatchString(media: AnimeSmartSearchOptions["media"]): string {
        const epCount = this.zeropad(media.episodeCount || 0)
        const parts = [
            `"01 - ${epCount}"`,
            `"01 ~ ${epCount}"`,
            `"Batch"`,
            `"Complete"`,
            `"+ OVA"`,
            `"+ Specials"`,
            `"+ Special"`,
            `"Seasons"`,
            `"Parts"`,
        ]
        return `(${parts.join("|")})`
    }

    private extractSeasonNumber(title: string): [number, string] {
        const match = title.match(/\b(season|s)\s*(\d{1,2})\b/i)
        if (match && match[2]) {
            const cleanTitle = title.replace(match[0], "").trim()
            return [parseInt(match[2]), cleanTitle]
        }
        return [0, title]
    }

    private extractPartNumber(title: string): [number, string] {
        const match = title.match(/\b(part|p)\s*(\d{1.2})\b/i)
        if (match && match[2]) {
            const cleanTitle = title.replace(match[0], "").trim()
            return [parseInt(match[2]), cleanTitle]
        }
        return [0, title]
    }

}


api:https://nyaa.si